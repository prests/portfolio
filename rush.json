/**
 * This is the main configuration file for Rush.
 * For full documentation, please see https://rushjs.io
 */
{
  "$schema": "https://developer.microsoft.com/json-schemas/rush/v5/rush.schema.json",
  "rushVersion": "5.77.3",
  "pnpmVersion": "6.7.1",
  "pnpmOptions": {
    "useWorkspaces": true
  },

  /**
   * Older releases of the Node.js engine may be missing features required by your system.
   * Other releases may have bugs.  In particular, the "latest" version will not be a
   * Long Term Support (LTS) version and is likely to have regressions.
   *
   * Specify a SemVer range to ensure developers use a Node.js version that is appropriate
   * for your repo.
   *
   * LTS schedule: https://nodejs.org/en/about/releases/
   * LTS versions: https://nodejs.org/en/download/releases/
   */
  "nodeSupportedVersionRange": ">=12.13.0 <13.0.0 || >=14.15.0 <15.0.0 || >=16.13.0 <17.0.0",
  "gitPolicy": {},

  "repository": {
    "url": "https://github.com/prests/shayne-website-frontend"
  },

  "eventHooks": {
    "preRushInstall": [],
    "postRushInstall": [],
    "preRushBuild": [],
    "postRushBuild": []
  },

  /**
   * Installation variants allow you to maintain a parallel set of configuration files that can be
   * used to build the entire monorepo with an alternate set of dependencies.  For example, suppose
   * you upgrade all your projects to use a new release of an important framework, but during a transition period
   * you intend to maintain compatibility with the old release.  In this situation, you probably want your
   * CI validation to build the entire repo twice: once with the old release, and once with the new release.
   *
   * Rush "installation variants" correspond to sets of config files located under this folder:
   *
   *   common/config/rush/variants/<variant_name>
   *
   * The variant folder can contain an alternate common-versions.json file.  Its "preferredVersions" field can be used
   * to select older versions of dependencies (within a loose SemVer range specified in your package.json files).
   * To install a variant, run "rush install --variant <variant_name>".
   *
   * For more details and instructions, see this article:  https://rushjs.io/pages/advanced/installation_variants/
   */
  "variants": [
    // {
    //   /**
    //    * The folder name for this variant.
    //    */
    //   "variantName": "old-sdk",
    //
    //   /**
    //    * An informative description
    //    */
    //   "description": "Build this repo using the previous release of the SDK"
    // }
  ],

  /**
   * Rush can collect anonymous telemetry about everyday developer activity such as
   * success/failure of installs, builds, and other operations.  You can use this to identify
   * problems with your toolchain or Rush itself.  THIS TELEMETRY IS NOT SHARED WITH MICROSOFT.
   * It is written into JSON files in the common/temp folder.  It's up to you to write scripts
   * that read these JSON files and do something with them.  These scripts are typically registered
   * in the "eventHooks" section.
   */
  // "telemetryEnabled": false,

  /**
   * Allows creation of hotfix changes. This feature is experimental so it is disabled by default.
   * If this is set, 'rush change' only allows a 'hotfix' change type to be specified. This change type
   * will be used when publishing subsequent changes from the monorepo.
   */
  // "hotfixChangeEnabled": false,

  /**
   * This is an optional, but recommended, list of allowed tags that can be applied to Rush projects
   * using the "tags" setting in this file.  This list is useful for preventing mistakes such as misspelling,
   * and it also provides a centralized place to document your tags.  If "allowedProjectTags" list is
   * not specified, then any valid tag is allowed.  A tag name must be one or more words
   * separated by hyphens or slashes, where a word may contain lowercase ASCII letters, digits,
   * ".", and "@" characters.
   */
  // "allowedProjectTags": [ "tools", "frontend-team", "1.0.0-release" ],

  /**
   * (Required) This is the inventory of projects to be managed by Rush.
   *
   * Rush does not automatically scan for projects using wildcards, for a few reasons:
   * 1. Depth-first scans are expensive, particularly when tools need to repeatedly collect the list.
   * 2. On a caching CI machine, scans can accidentally pick up files left behind from a previous build.
   * 3. It's useful to have a centralized inventory of all projects and their important metadata.
   */
  "projects": [
    {
      "packageName": "app",
      "projectFolder": "packages/app"
    }
    // {
    //   /**
    //    * The NPM package name of the project (must match package.json)
    //    */
    //   "packageName": "my-app",
    //
    //   /**
    //    * The path to the project folder, relative to the rush.json config file.
    //    */
    //   "projectFolder": "apps/my-app",
    //
    //   /**
    //    * An optional category for usage in the "browser-approved-packages.json"
    //    * and "nonbrowser-approved-packages.json" files.  The value must be one of the
    //    * strings from the "reviewCategories" defined above.
    //    */
    //   "reviewCategory": "production",
    //
    //   /**
    //    * A list of Rush project names that are to be installed from NPM
    //    * instead of linking to the local project.
    //    *
    //    * If a project's package.json specifies a dependency that is another Rush project
    //    * in the monorepo workspace, normally Rush will locally link its folder instead of
    //    * installing from NPM.  If you are using PNPM workspaces, this is indicated by
    //    * a SemVer range such as "workspace:^1.2.3".  To prevent mistakes, Rush reports
    //    * an error if the "workspace:" protocol is missing.
    //    *
    //    * Locally linking ensures that regressions are caught as early as possible and is
    //    * a key benefit of monorepos.  However there are occasional situations where
    //    * installing from NPM is needed.  A classic example is a cyclic dependency.
    //    * Imagine three Rush projects: "my-toolchain" depends on "my-tester", which depends
    //    * on "my-library".  Suppose that we add "my-toolchain" to the "devDependencies"
    //    * of "my-library" so it can be built by our toolchain.  This cycle creates
    //    * a problem -- Rush can't build a project using a not-yet-built dependency.
    //    * We can solve it by adding "my-toolchain" to the "decoupledLocalDependencies"
    //    * of "my-library", so it builds using the last published release.  Choose carefully
    //    * which package to decouple; some choices are much easier to manage than others.
    //    *
    //    * (In older Rush releases, this setting was called "cyclicDependencyProjects".)
    //    */
    //   "decoupledLocalDependencies": [
    //     // "my-toolchain"
    //   ],
    //
    //   /**
    //    * If true, then this project will be ignored by the "rush check" command.
    //    * The default value is false.
    //    */
    //   // "skipRushCheck": false,
    //
    //   /**
    //    * A flag indicating that changes to this project will be published to npm, which affects
    //    * the Rush change and publish workflows. The default value is false.
    //    * NOTE: "versionPolicyName" and "shouldPublish" are alternatives; you cannot specify them both.
    //    */
    //   // "shouldPublish": false,
    //
    //   /**
    //    * Facilitates postprocessing of a project's files prior to publishing.
    //    *
    //    * If specified, the "publishFolder" is the relative path to a subfolder of the project folder.
    //    * The "rush publish" command will publish the subfolder instead of the project folder.  The subfolder
    //    * must contain its own package.json file, which is typically a build output.
    //    */
    //   // "publishFolder": "temp/publish",
    //
    //   /**
    //    * An optional version policy associated with the project.  Version policies are defined
    //    * in "version-policies.json" file.  See the "rush publish" documentation for more info.
    //    * NOTE: "versionPolicyName" and "shouldPublish" are alternatives; you cannot specify them both.
    //    */
    //   // "versionPolicyName": "",
    //
    //   /**
    //    * An optional set of custom tags that can be used to select this project.  For example,
    //    * adding "my-custom-tag" will allow this project to be selected by the
    //    * command "rush list --only tag:my-custom-tag".  The tag name must be one or more words
    //    * separated by hyphens or slashes, where a word may contain lowercase ASCII letters, digits,
    //    * ".", and "@" characters.
    //    */
    //   // "tags": [ "1.0.0-release", "frontend-team" ]
    // },
    //
    // {
    //   "packageName": "my-controls",
    //   "projectFolder": "libraries/my-controls",
    //   "reviewCategory": "production",
    //   "tags": [ "frontend-team" ]
    // },
    //
    // {
    //   "packageName": "my-toolchain",
    //   "projectFolder": "tools/my-toolchain",
    //   "reviewCategory": "tools",
    //   "tags": [ "tools" ]
    // }
  ]
}
